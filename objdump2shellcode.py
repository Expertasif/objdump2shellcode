#!/usr/bin/env python
#
# MIT License
#
# Copyright (c) 2017 Milton Valencia
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# Script name     : objdump2shellcode.py
# Version         : 3.2
# Created date    : 5/27/2017
# Last update     : 8/14/2017
# Author          : wetw0rk
# Python version  : 2.7
# Designed OS	  : Linux
# Dependencies	  : none, besides objdump; installed on most os's
# Description     : This is 1000000000 times easier than manually
#                   copying/pasting custom shellcode generated by
#                   objdump. I noticed Black Arch is hosting this
#		    this tool aswell :D so I added more features!
#

import os, sys, subprocess, argparse

snipit          = []
instructions    = []
opcodes         = []
no_junk         = []
bad_char_line   = ""
ops		= ""
bad		= ""

def format_list():

	supported_norm = [
	'hex',
	'nasm',
	'c',
	'perl',
	'python',
	'bash',
	'csharp',
	'dword',
	'java',
	'num',
	'powershell',
	'ruby',
	]

	supported_comment = [
	'python',
	'c',
	'perl',
	]

	sn = "\t"
	sc = "\t"

	# normal dumpable languages
	print "Normal output:"
	for i in range(len(supported_norm)):
		sn += "%s, " % supported_norm[i]

	print sn[:len(sn)-2]

	# comment supported languages
	print "Comment dump:"
	for i in range(len(supported_comment)):
		sc += "%s, " % (supported_comment[i])

	print sc[:len(sc)-2]

def clean_output(split, badchars):

	global bad_char_line, instructions
	global snipit, opcodes, no_junk, ops
	global bad

	for i in range(len(split)):
		# split up every line by a [tab] and remove address
		line = split[i].split('\t')[1:3]
		# get rid of blank lines
		if len(line) > 0:
			snipit += line
		else:
			pass
	# separate opcodes and instructions
	list_len = len(snipit)
	for i in range(list_len):
		if (i & 1) == 1:
			instructions += snipit[i],
		else:
			opcodes += snipit[i],

	# cut off the junk!!!
	for i in range(len(opcodes)):
		no_junk  += opcodes[i].rstrip(" "),


	# this will aid in bad character verification
	for i in range(len(opcodes)):
		opcodes[i] = opcodes[i].rstrip(" ")

	for i in range(len(opcodes)):
		ops += "\\x%s" % opcodes[i].replace(" ", "\\x")

	try:
		stop_now = badchars.split(",")
		for i in range(len(stop_now)):
			if stop_now[i] in ops:
				bad += "%s" % stop_now[i]
		if len(bad) > 1:
			print "Bad characters spotted: %s" % (bad)
		else:
			pass
	except:
		pass

	print "Payload size: %d bytes" % (len(ops)/4)

	return

class format_dump():

	def __init__(self, intel_dump, mode, badchars, var_name):
		self.intel_dump		= intel_dump
		self.mode		= mode
		self.badchars		= badchars
		self.var_name		= var_name

	def tact_dump(self):

		split = self.intel_dump.split("\n")

		# apart stuff
		clean_output(split, self.badchars)

		if self.mode == "python":
			print '%s = ""' % (self.var_name)
			splits = [ops[x:x+60] for x in range(0,len(ops),60)]
			for i in range(len(splits)):
				print self.var_name + " += \"" + splits[i] + "\""

		if self.mode == "c":
			print "unsigned char %s[] = " % (self.var_name)
			splits = [ops[x:x+60] for x in range(0,len(ops),60)]
			for i in range(len(splits)):
				if i == (len(splits) -1):
					print "\"" + splits[i] + "\"" + ";"
				else:
					print "\"" + splits[i] + "\""

		if self.mode == "bash":
			print "export %s=\\" % (self.var_name)
			splits = [ops[x:x+56] for x in range(0,len(ops),56)]
			for i in range(len(splits)):
				if i == (len(splits) -1):
					print "$'" + splits[i] + "'"
				else:
					print "$'" + splits[i] + "'" + "\\"

		if self.mode == "ruby":
			print "%s = " % (self.var_name)
			splits = [ops[x:x+56] for x in range(0,len(ops),56)]
			for i in range(len(splits)):
				if i == (len(splits) -1):
					print "\"" + splits[i] + "\""
				else:
					print "\"" + splits[i] + "\"" + " +"

		if self.mode == "csharp":
			print "byte[] %s = new byte[%d] {" % (self.var_name, (len(ops)/4))
			sharp = ""
			asm_ops = ops.split("\\x")
			for i in range(len(asm_ops)):
				if asm_ops[i] == '':
					pass
				else:
					sharp += "0x%s," % (asm_ops[i])
			split = [sharp[x:x+75] for x in range(0,len(sharp),75)]
			for i in range(len(split)):
				snip = len(split[i]) - 1
				if i == (len(split)-1):
					print split[i][:snip] + " };"
				else:
					print split[i]

		if self.mode == "dword":
			dword = ""
			dlist = []
			asm_ops = ops.split("\\x")
			for i in range(len(asm_ops)):
				if asm_ops[i] == '':
					pass
				else:
					dword += "%s" % (asm_ops[i])
			splits = [dword[x:x+8] for x in range(0,len(dword),8)]
			for i in range(len(splits)):
				s = splits[i]
				dlist += "0x" + "".join(map(str.__add__, s[-2::-2] ,s[-1::-2])),

			for i in range(len(dlist)/8+1):
				print ", ".join(dlist[i*8:(i+1)*8])

		if self.mode == "perl":
			print "my $%s =" % (self.var_name)
			splits = [ops[x:x+60] for x in range(0,len(ops),60)]
			for i in range(len(splits)):
				if i == (len(splits) -1):
					print "\"" + splits[i] + "\"" + ";"
				else:
					print "\"" + splits[i] + "\"" + " ."

		if self.mode == "nasm":
			nasm = ""
			asm_ops = ops.split("\\x")
			for i in range(len(asm_ops)):
				if asm_ops[i] == '':
					pass
				else:
					nasm += "0x%s," % (asm_ops[i])
			split = [nasm[x:x+40] for x in range(0,len(nasm),40)]
			for i in range(len(split)):
				snip = len(split[i]) - 1
				print "db " + split[i][:snip]

		if self.mode == "num":
			raw_ops = ""
			asm_ops = ops.split("\\x")
			for i in range(len(asm_ops)):
				if asm_ops[i] == '':
					pass
				else:
					raw_ops += "0x%s, " % (asm_ops[i])
			split = [raw_ops[x:x+84] for x in range(0,len(raw_ops),84)]
			for i in range(len(split)):
				snip = len(split[i]) - 2
				if i == (len(split)-1):
					print split[i][:snip]
				else:
					print split[i]

		if self.mode == "powershell":
			raw_ops = ""
			asm_ops = ops.split("\\x")
			for i in range(len(asm_ops)):
				if asm_ops[i] == '':
					pass
				else:
					raw_ops += "0x%s," % (asm_ops[i])
			split = [raw_ops[x:x+50] for x in range(0,len(raw_ops),50)]
			for i in range(len(split)):
				snip = len(split[i]) - 1
				if i == 0:
					print "[Byte[]] %s = %s" % (self.var_name, split[i][:snip])
				else:
					print "$%s += %s" % (self.var_name, split[i][:snip])

		if self.mode == "java":
			print "byte %s[] = new byte[]" % (self.var_name)
			print "{"
			javop = ""
			javlt = []
			asm_ops = ops.split("\\x")
			for i in range(len(asm_ops)):
				if asm_ops[i] == '':
					pass
				else:
					javop += "%s" % (asm_ops[i])
			splits = [javop[x:x+2] for x in range(0,len(javop),2)]
			for i in range(len(splits)):
				s = splits[i]
				javlt  += "(byte) 0x" + "".join(map(str.__add__, s[-2::-2] ,s[-1::-2])),
			for i in range(len(javlt)/8+1):
				if i < (len(javlt)/8):
					print  "\t" + ", ".join(javlt[i*8:(i+1)*8]) + ","
				else:
					print "\t" + ", ".join(javlt[i*8:(i+1)*8])
			print "};"

		if self.mode == "hex":
			asm_raw = ""
			asm_ops = ops.split("\\x")
			for i in range(len(asm_ops)):
				if asm_ops[i] == '':
					pass
				else:
					asm_raw += "%s" % (asm_ops[i])
			print asm_raw

	def info_dump(self):

		split = self.intel_dump.split("\n")

		# apart stuff
		clean_output(split, self.badchars)

		if self.mode == "python":
			print '%s = ""' % (self.var_name)
			for i in range(len(no_junk)):
				print(self.var_name + " += \"\\x%s\"\t# %s" % (
					no_junk[i].replace(" ", "\\x"),
					instructions[i])
				).expandtabs(30)

		if self.mode == "c":
			print "unsigned char %s[] = " % (self.var_name)
			for i in range(len(no_junk)):
				if i != (len(no_junk)-1):
					print("\"\\x%s\"\t// %s" % (
						no_junk[i].replace(" ", "\\x"),
						instructions[i])
					).expandtabs(30)
				else:
					print("\"\\x%s\";\t// %s" % (
						no_junk[i].replace(" ", "\\x"),
						instructions[i])
					).expandtabs(30)

		if self.mode == "perl":
			print "my $%s =" % (self.var_name)
			for i in range(len(no_junk)):
				if i != (len(no_junk)-1):
					print("\"\\x%s\".\t# %s" % (
						no_junk[i].replace(" ", "\\x"),
						instructions[i])
					).expandtabs(30)
				else:
					print("\"\\x%s\";\t# %s" % (
						no_junk[i].replace(" ", "\\x"),
						instructions[i])
					).expandtabs(30)

def begin_dump(dumpfile, mode, badchars, comment_code, var_name):

	# detect if the file exists
	if os.path.isfile(dumpfile) is False:
		print "File non-existent!"
		sys.exit()

	# run objdump to disassemble the binary
	try:
		intel_dump = subprocess.Popen(['objdump', '-D', dumpfile, '-M', 'intel'],
			stdout=subprocess.PIPE).communicate()[0]
	except:
		print "[-] error running command"
		sys.exit()

	# format the output dump accordingly
	if comment_code:
		format = format_dump(intel_dump, mode, badchars, var_name)
		format.info_dump()
	else:
		format = format_dump(intel_dump, mode, badchars, var_name)
		format.tact_dump()

def main():
	# handle command line arguments
	parser = argparse.ArgumentParser()
	parser.add_argument("-d", "--dump",	help="Binary to dump shellcode from")
	parser.add_argument("-f", "--format",	help="Output format (use --list for a list)")
	parser.add_argument("-b", "--badchar",	help="Seperate badchars like so \\x00,\\x0a")
	parser.add_argument("-c", "--comment",	help="Comments the shellcode output", action="store_true")
	parser.add_argument("-v", "--varname",	required=False, help="alternative variable name")
	parser.add_argument("-l", "--list",	help="List available formats", action="store_true")
	args = parser.parse_args()
	# assign arguments
	dumpfile	= args.dump
	mode		= args.format
	badchars	= args.badchar
	comment_code	= args.comment

	# if a list is requested print it
	if args.list == True:
		format_list()
		sys.exit()

	# default variable name if none given
	if args.varname < 1:
		var_name = "buf"
	else:
		var_name = args.varname

	# pass to function (thank you @justsam)
	if dumpfile > 1:
		begin_dump(dumpfile, mode, badchars, comment_code, var_name)
	else:
		print(parser.print_help())

if __name__ == '__main__':
	main()
